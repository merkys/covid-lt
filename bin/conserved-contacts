#!/usr/bin/Rscript --vanilla

# Script reads a matrix of contacts, where columns are complexes and rows are positions in the aligned chain within a complex.
# Script then outputs the most conserved contacts.
# The number of such contacts is equal to the average number of contacts in complexes.

library( "optparse" )
parser <- OptionParser()
parser <- add_option(parser, c( '--input-list' ), dest = 'input_list', action = "store_true", default = FALSE)
options = parse_args(parser, positional_arguments = TRUE)

file = '/dev/stdin'
files = options$args
if( length(files) != 0 ) {
    file = files[1]
}

n_contacts = NULL
contact_abundance = NULL

if( !options$options$input_list ) {
    suppressWarnings( D <- read.csv( file, header = TRUE, sep = "\t", na.strings = "?" ) )

    # Calculate the number of contacts per column
    n_contacts = vector( length=dim(D)[2] )
    for (i in 1:dim(D)[2]) {
        n_contacts[i] = length(D[!is.na(D[,i]),i])
    }

    # Calculate the abundance of each of the contacts in the group
    contact_abundance = vector( length=dim(D)[1] )
    for (i in 1:dim(D)[1]) {
        contact_abundance[i] = length( D[i,!is.na(D[i,])] ) / length( D[i,] )
    }
} else {
    suppressWarnings( lines <- readLines( file ) )

    # Print an empty line if input is empty
    if( length(lines) == 0 ) {
        cat( "\n" )
        quit()
    }

    # Calculate the number of contacts per line
    n_contacts = vector( length=length(lines) )
    for (i in 1:length(lines)) {
        n_contacts[i] = length( strsplit( lines[i], ',' )[[1]] )
    }

    # Calculate the abundance of each of the contacts in the group
    contact_abundance = vector()
    for (i in 1:length(lines)) {
        for (pos in as.numeric( strsplit( lines[i], ',' )[[1]] )) {
            if( length( contact_abundance ) < pos ) {
                contact_abundance[pos] = 1
            } else if( is.na( contact_abundance[pos] ) ) {
                contact_abundance[pos] = 1
            } else {
                contact_abundance[pos] = contact_abundance[pos] + 1
            }
        }
    }
    contact_abundance[is.na(contact_abundance)] = 0
    contact_abundance = contact_abundance / length(lines)
}

# Perform a binary search to select a threshold percentage
low_bound = 0
high_bound = 1

last_mid = NULL

while (TRUE) {
    mid = mean( c( low_bound, high_bound ) )
    if( length( contact_abundance[contact_abundance > mid] ) > mean( n_contacts ) ) {
        low_bound = mid
    } else {
        high_bound = mid
    }
    if( !is.null(last_mid) && abs( last_mid - mid ) < 1e-6 ) {
        break
    }
    last_mid = mid
}

# Filtering out "rare" contacts
if( !options$options$input_list ) {
    for (i in 1:dim(D)[1]) {
        if( contact_abundance[i] > last_mid ) {
            cat( mean( as.double( D[i,] ), na.rm = TRUE ), "\n" )
        } else {
            cat( "?\n" )
        }
    }
} else {
    positions = 1:length( contact_abundance )
    cat( positions[contact_abundance > last_mid], sep = ',' )
    cat( "\n" )
}
