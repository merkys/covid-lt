#!/usr/bin/python3

import argparse, re, sys

def create_atom(fields):
    return { 'chain': fields[0],
             'res_nr': fields[1],
             'atom_nr': fields[2],
             'res_type': fields[3],
             'atom_type': fields[4] }

def write_atom(atom):
    return '\t'.join([atom['chain'], atom['res_nr'], atom['res_type'], atom['atom_nr'], atom['atom_type']])

def register_contact(contacts, atom1, atom2, distance, area):
    if atom1['chain'] not in contacts:
        contacts[atom1['chain']] = {}
    if atom1['res_nr'] not in contacts[atom1['chain']]:
        contacts[atom1['chain']][atom1['res_nr']] = {}
    if atom2['chain'] not in contacts[atom1['chain']][atom1['res_nr']]:
        contacts[atom1['chain']][atom1['res_nr']][atom2['chain']] = {}
    if atom2['res_nr'] not in contacts[atom1['chain']][atom1['res_nr']][atom2['chain']]:
        contacts[atom1['chain']][atom1['res_nr']][atom2['chain']][atom2['res_nr']] = []
    contacts[atom1['chain']][atom1['res_nr']][atom2['chain']][atom2['res_nr']].append([atom1, atom2, distance, area])

def is_possible_salt_bridge(atom1, atom2):
    types = {}
    for atom in [atom1, atom2]:
        types[atom['res_type']] = atom
    if 'ARG' not in types and 'LYS' not in types:
        return False
    if 'ASP' not in types and 'GLU' not in types:
        return False
    if 'ARG' in types and types['ARG']['atom_type'] not in ['NH1', 'NH2']:
        return False
    if 'LYS' in types and types['LYS']['atom_type'] != 'NZ':
        return False
    if 'ASP' in types and types['ASP']['atom_type'] not in ['OD1', 'OD2']:
        return False
    if 'GLU' in types and types['GLU']['atom_type'] not in ['OE1', 'OE2']:
        return False
    return True

atom_re = 'c<([^>]+)>r<(\d+)>a<(\d+)>R<([^>]+)>A<([^>]+)>'
contact_re = atom_re + '\s+' + atom_re + '\s+(\S+)\s+(\S+)'

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--chain', action='append')
# Minimal distance between any two atoms in residues is taken as the distance between them, just as in ProteinTools, ref:
# Ferruz et al., doi:10.1093/nar/gkab375
parser.add_argument('--dist', choices=['min'])
parser.add_argument('--select-salt-bridges', action='store_true')
args = parser.parse_args()

chains = []
if args.chain:
    chains = sorted(args.chain)

files = args.files
if len(files) == 0:
    files = [sys.stdin]

for file in files:
    if isinstance(file, str):
        file = open(file, 'r')
    contacts = {}
    for line in file:
        match = re.match(contact_re, line)
        if match:
            atom1 = create_atom([match.group(i) for i in range(1, 6)])
            atom2 = create_atom([match.group(i) for i in range(6, 11)])
            if len(chains) == 1:
                if atom1['chain'] != chains[0] or atom2['chain'] != chains[0]:
                    continue
            elif len(chains) == 2:
                if atom1['chain'] != chains[0] or atom2['chain'] != chains[1]:
                    continue
            area = match.group(11)
            distance = match.group(12)
            register_contact(contacts, atom1, atom2, distance, area)
            if args.dist:
                continue
            # Salt bridge filtering is implemented as in ProteinTools, ref:
            # Ferruz et al., doi:10.1093/nar/gkab375
            if args.select_salt_bridges and \
                (not is_possible_salt_bridge(atom1, atom2) or
                 float(distance) > 4):
                continue
            print(write_atom(atom1), write_atom(atom2), sep='\t')
    if args.dist:
        for c1 in contacts:
            for r1 in contacts[c1]:
                for c2 in contacts[c1][r1]:
                    for r2 in contacts[c1][r1][c2]:
                        print(c1, r1, c2, r2, min([contact[2] for contact in contacts[c1][r1][c2][r2]]), sep='\t')
