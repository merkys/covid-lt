#!/usr/bin/env python3

from Bio import AlignIO, PDB, SeqIO, pairwise2
from Bio.Seq import MutableSeq
from Bio.SeqRecord import SeqRecord
from ost import io, seq
from pdbio.pdbfile import PDBFile
from promod3 import modelling
from tempfile import NamedTemporaryFile
from warnings import filterwarnings, warn
import argparse, re, sys

filterwarnings('ignore', category=PDB.PDBExceptions.PDBConstructionWarning)

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--trim', action='store_true', help='Trim nonmodelled residues')
parser.add_argument('--simulate', action='store_true', help='Perform a simulation on resulting model')
parser.add_argument('--forcefield', help='Specify the forcefield ("AMBER" by default)', choices=['AMBER', 'CHARMM'] default='CHARMM')
args = parser.parse_args()

file = args.files[0] # for now

# Extract sequences from the input file
atom_seqs = [s for s in SeqIO.parse(file, 'pdb-atom')]
seqres_seqs = [s for s in SeqIO.parse(file, 'pdb-seqres')]
chains = [s.id[5] for s in atom_seqs]

# TODO: Check if chains are the same

first = {}
last = {}
chains = []
for line in open(file, 'r').readlines():
    if line[0:6] != 'ATOM  ':
        continue
    chain = line[21]
    resno = int(line[22:26])
    if not chain in chains:
        chains.append(chain)
    if not chain in first:
        first[chain] = resno
    last[chain] = resno

atom_seqs_by_chain = {}
for s in atom_seqs:
    atom_seqs_by_chain[s.id[5]] = s
seqres_seqs_by_chain = {}
for s in seqres_seqs:
    chain = s.id
    if len(chain) > 1: # This is probably a problem with Bio module
        chain = chain[5]
    seqres_seqs_by_chain[chain] = s

sequence_seq = None
structure_seq = None

pdbid = None

pdb = io.LoadPDB(file)
alignments = seq.AlignmentList()

for chain in chains:
    atom_seq = atom_seqs_by_chain[chain]
    seqres_seq = seqres_seqs_by_chain[chain]
    # TODO: Check if such exists
    align = pairwise2.align.globalxx(seqres_seq.seq, atom_seq.seq, one_alignment_only=True)[0]
    sequence = MutableSeq(align[0])
    structure = MutableSeq(align[1])
    pdbid, chain = seqres_seq.id.split(':')

    pos = 0
    while pos < len(structure):
        if structure[pos] == 'X':
            structure[pos] = '-'
            if sequence[pos] == '-':
                del(structure[pos])
                del(sequence[pos])
                continue
        pos += 1

    if args.trim:
        start = re.search('^(-+)', str(structure))
        end = re.search('(-+)$', str(structure))
        if start:
            start = len(start.group(1))
        if end:
            end = -len(end.group(1))
        structure = structure[start:end]
        sequence = sequence[start:end]

    alignment = seq.CreateAlignment(seq.CreateSequence('trg_' + chain, str(sequence)),
                                    seq.CreateSequence('tpl_' + chain, str(structure)))

    # There must be an easier way to do this...
    view = pdb.CreateFullView()
    for ch in view.chains:
        if str(ch) != chain:
            view.RemoveChain(ch)
    alignment.AttachView(1, view)
    alignments.append(alignment)

handle = modelling.BuildRawModel(alignments)
modelling.CloseGaps(handle)
modelling.BuildSidechains(handle)
model = handle.model

if args.simulate:
    from ost.mol import mm
    # Parameters as suggested by Gabriel Studer
    settings = mm.Settings()
    settings.integrator = mm.LangevinIntegrator(310, 1, 0.002)
    settings.init_temperature = 0
    settings.nonbonded_method = mm.NonbondedMethod.CutoffNonPeriodic
    settings.keep_ff_specific_naming = False
    if args.forcefield == 'AMBER':
        settings.forcefield = mm.LoadAMBERForcefield()
    if args.forcefield == 'CHARMM':
        settings.forcefield = mm.LoadCHARMMForcefield()
    simulation = mm.Simulation(model, settings)
    model = simulation.GetEntity()

# Check if the resulting PDB file does not have gaps
output_pdb_file = NamedTemporaryFile()
io.SavePDB(model, output_pdb_file.name)
pdb = PDBFile(output_pdb_file.name)
for chain in pdb:
    if not chain.is_contiguous():
        warn('{}: chain {} is not contiguous after fixing'.format(file, chain.name))
print(pdb, end='')
