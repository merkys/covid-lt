#!/usr/bin/env python3

from Bio import BiopythonDeprecationWarning, pairwise2
from Bio.Seq import MutableSeq
from ost import io, seq
from pdbio import PDBFile
from promod3 import modelling
from tempfile import NamedTemporaryFile
from warnings import filterwarnings, warn
import argparse, re, sys

filterwarnings('ignore', category=BiopythonDeprecationWarning)

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--trim', action='store_true', help='Trim nonmodelled residues')
parser.add_argument('--do-not-fill-gaps', action='store_true', help='Do not fill gaps')
parser.add_argument('--simulate', action='store_true', help='Perform a simulation on resulting model')
parser.add_argument('--forcefield', help='Specify the forcefield ("AMBER" by default)', choices=['AMBER', 'CHARMM'], default='AMBER')
parser.add_argument('--replace', action='append', help='Perform mutation (replacement), may be multiple', default=[])
parser.add_argument('--output-alignment-only', action='store_true', help='Do not perform the modeling, only output the alignment used for modeling')
parser.add_argument('--output-sequence-only', action='store_true', help='Do not perform the modeling, only output the sequence used for modeling')
args = parser.parse_args()

file = None
if len(args.files):
    file = args.files[0] # for now
else:
    temporary_file = NamedTemporaryFile('w+')
    temporary_file.write(sys.stdin.read())
    file = temporary_file.name

pdb = io.LoadPDB(file)
alignments = seq.AlignmentList()

replacements = []
for replacement in args.replace:
    m = re.fullmatch('([A-Z])([A-Z])([0-9]+)([A-Z])', replacement)
    if not m:
        warn('mutation {} cannot be parsed'.format(replacement))
        continue
    replacements.append({ 'from': m.group(1), 'chain': m.group(2), 'position': int(m.group(3)), 'to': m.group(4), 'full': replacement })

original_chains = []
for chain in PDBFile(file):
    original_chains.append(chain.name)

    if args.do_not_fill_gaps:
        continue

    atom_seq = chain.sequence_atom(with_gaps=True)
    seqres_seq = chain.sequence_seqres(replace_unknown_with='-')

    for replacement in replacements:
        if replacement['chain'] != chain.name:
            continue
        if atom_seq[replacement['position']-1] != replacement['from']:
            warn('mutation {} does not match sequence'.format(replacement['full']))
            continue
        replacement['offset'] = replacement['position'] - 1 - atom_seq[0:replacement['position']].count('-')

    # NW parameters taken from https://www.arabidopsis.org/Blast/BLASToptions.jsp
    align = pairwise2.align.globalms(seqres_seq, atom_seq, 1, -3, -5, -2, one_alignment_only=True)[0]
    sequence = MutableSeq(align[0])
    structure = MutableSeq(align[1])

    # Replace 'X' (gaps) with '-', perform mutations if any
    pos = 0
    for i, aa in enumerate(structure):
        if aa in ['X', '-']:
            structure[i] = '-'
            continue
        for replacement in replacements:
            if replacement['chain'] != chain.name:
                continue
            if replacement['offset'] != pos:
                continue
            sequence[i] = replacement['to']
        pos += 1

    # Cleanup common gaps
    pos = 0
    while pos < len(structure):
        if structure[pos] == '-' and sequence[pos] == '-':
            del(structure[pos])
            del(sequence[pos])
            continue
        pos += 1

    if args.trim:
        start = re.search('^(-+)', str(structure))
        end = re.search('(-+)$', str(structure))
        if start:
            start = len(start.group(1))
        if end:
            end = -len(end.group(1))
        structure = structure[start:end]
        sequence = sequence[start:end]

    if args.output_alignment_only:
        print('>', chain.name + ':sequence')
        print(sequence)
        print('>', chain.name + ':structure')
        print(structure)

    if args.output_sequence_only:
        print('>', chain.name)
        print(sequence)

    alignment = seq.CreateAlignment(seq.CreateSequence('trg_' + chain.name, str(sequence)),
                                    seq.CreateSequence('tpl_' + chain.name, str(structure)))

    # There must be an easier way to do this...
    view = pdb.CreateFullView()
    for ch in view.chains:
        if str(ch) != chain.name:
            view.RemoveChain(ch)
    alignment.AttachView(1, view)
    alignments.append(alignment)

if args.output_sequence_only:
    sys.exit()

if not args.do_not_fill_gaps:
    handle = modelling.BuildRawModel(alignments)
    modelling.CloseGaps(handle)
    modelling.BuildSidechains(handle)
    model = handle.model
else:
    model = pdb

if args.simulate:
    from ost.mol import mm
    # Parameters as suggested by Gabriel Studer
    settings = mm.Settings()

    # Find the most suitable platform
    for platform in [mm.Platform.CUDA, mm.Platform.OpenCL, mm.Platform.CPU, mm.Platform.Reference]:
        settings.platform = platform
        if mm.Simulation.IsPlatformAvailable(settings):
            break

    settings.integrator = mm.LangevinIntegrator(310, 1, 0.002)
    settings.init_temperature = 0
    settings.nonbonded_method = mm.NonbondedMethod.CutoffNonPeriodic
    settings.keep_ff_specific_naming = False

    if args.forcefield == 'AMBER':
        settings.forcefield = mm.LoadAMBERForcefield()
    if args.forcefield == 'CHARMM':
        settings.forcefield = mm.LoadCHARMMForcefield()

    simulation = mm.Simulation(model, settings)
    model = simulation.GetEntity()

output_pdb_file = NamedTemporaryFile()
io.SavePDB(model, output_pdb_file.name)

pdb = PDBFile(output_pdb_file.name)

# Restore the original chain names
chains_now = []
for chain in pdb:
    chains_now.append(chain.name)
pdb.rename_chains(dict(zip(chains_now, original_chains)))

for chain in pdb:
    # Check if the resulting PDB file does not have gaps
    if not chain.is_contiguous():
        warn('{}: chain {} is not contiguous after fixing'.format(file, chain.name))

    # Not sure why, but ProMod3 adds OXT atoms as H, not O.
    for residue in chain:
        for atom in residue:
            if atom.name() == 'OXT':
                atom.element('O')
print(pdb, end='')
