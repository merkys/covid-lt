#!/usr/bin/env python3

from Bio import AlignIO, PDB, SeqIO, pairwise2
from Bio.Seq import MutableSeq
from Bio.SeqRecord import SeqRecord
from promod3 import modelling
from subprocess import Popen, PIPE
import argparse, re, sys, warnings

warnings.filterwarnings('ignore', category=PDB.PDBExceptions.PDBConstructionWarning)

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--trim', action='store_true', help='Trim nonmodelled residues')
parser.add_argument('--simulate', action='store_true', help='Perform a simulation on resulting model')
args = parser.parse_args()

file = args.files[0] # for now

# Extract sequences from the input file
atom_seqs = [seq for seq in SeqIO.parse(file, 'pdb-atom')]
seqres_seqs = [seq for seq in SeqIO.parse(file, 'pdb-seqres')]
chains = [seq.id[5] for seq in atom_seqs]

# TODO: Check if chains are the same

first = {}
last = {}
chains = []
for line in open(file, 'r').readlines():
    if line[0:6] != 'ATOM  ':
        continue
    chain = line[21]
    resno = int(line[22:26])
    if not chain in chains:
        chains.append(chain)
    if not chain in first:
        first[chain] = resno
    last[chain] = resno

atom_seqs_by_chain = {}
for seq in atom_seqs:
    atom_seqs_by_chain[seq.id[5]] = seq
seqres_seqs_by_chain = {}
for seq in seqres_seqs:
    chain = seq.id
    if len(chain) > 1: # This is probably a problem with Bio module
        chain = chain[5]
    seqres_seqs_by_chain[chain] = seq

sequence_seq = None
structure_seq = None

pdbid = None

from ost import io, seq

pdb = io.LoadPDB(file)
alignments = seq.AlignmentList()

for chain in chains:
    atom_seq = atom_seqs_by_chain[chain]
    seqres_seq = seqres_seqs_by_chain[chain]
    # TODO: Check if such exists
    align = pairwise2.align.globalxx(seqres_seq.seq, atom_seq.seq, one_alignment_only=True)[0]
    print(align, file=sys.stderr)
    sequence = MutableSeq(align[0])
    structure = MutableSeq(align[1])
    pdbid, chain = seqres_seq.id.split(':')

    pos = 0
    while pos < len(structure):
        if structure[pos] == 'X':
            structure[pos] = '-'
            if sequence[pos] == '-':
                del(structure[pos])
                del(sequence[pos])
                continue
        pos += 1

    if args.trim:
        start = re.search('^(-+)', str(structure))
        end = re.search('(-+)$', str(structure))
        if start:
            start = len(start.group(1))
        if end:
            end = -len(end.group(1))
        structure = structure[start:end]
        sequence = sequence[start:end]

    alignment = seq.CreateAlignment(seq.CreateSequence('trg_' + chain, str(sequence)),
                                    seq.CreateSequence('tpl_' + chain, str(structure)))

    # There must be an easier way to do this...
    view = pdb.CreateFullView()
    for ch in view.chains:
        if str(ch) != chain:
            view.RemoveChain(ch)
    alignment.AttachView(1, view)
    alignments.append(alignment)

handle = modelling.BuildRawModel(alignments)
modelling.CloseGaps(handle)
modelling.BuildSidechains(handle)
model = handle.model

if args.simulate:
    from ost.mol import mm
    # Parameters as suggested by Gabriel Studer
    settings = mm.Settings()
    settings.integrator = mm.LangevinIntegrator(310, 1, 0.002)
    settings.init_temperature = 0
    settings.nonbonded_method = mm.NonbondedMethod.CutoffNonPeriodic
    settings.keep_ff_specific_naming = False
    settings.forcefield = mm.LoadCHARMMForcefield()
    simulation = mm.Simulation(model, settings)
    model = simulation.GetEntity()

io.SavePDB(model, '/dev/stdout')
