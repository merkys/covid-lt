#!/usr/bin/python3

from numpy import histogram
from pdbio.pdbfile import PDBFile
from warnings import warn
import argparse, sys

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--max-length', default=500, help='Maximum length of S1 chain')
parser.add_argument('--S1-chain', default='A', help='Specify the S1 chain')
parser.add_argument('--contacts', help='Specify a file listing contacts between S1 and other chains')
args = parser.parse_args()

files = args.files
if len(files) == 0:
    files = [sys.stdin]

# Cuts are taken from https://pfam.xfam.org/protein/P0DTC2
S1_domain_cuts = [ 0, 24, 342, 531, 600, 705 ]

contacts = None

# Collect contacts of S1 chain with other chains
if args.contacts:
    contacts = {}
    for line in open(args.contacts, 'r'):
        atom1, atom2 = {}, {}
        fields = line.strip().split('\t')
        atom1['chain'], atom1['res_nr'], atom1['res_type'], atom1['atom_nr'], atom1['atom_type'], \
            atom2['chain'], atom2['res_nr'], atom2['res_type'], atom2['atom_nr'], atom2['atom_type'], *fields = fields
        if not ((atom1['chain'] == args.S1_chain) ^ (atom2['chain'] == args.S1_chain)):
            continue
        if atom1['chain'] != args.S1_chain: # Making atom1 the S1 chain atom
            atom1, atom2 = atom2, atom1
        if atom2['chain'] not in contacts:
            contacts[atom2['chain']] = set()
        contacts[atom2['chain']].add(int(atom1['res_nr']))

for filename in files:
    pdb = PDBFile(filename)

    # Find contacts that are visible in the PDB file
    contacts_now = set()
    for chain in pdb:
        if contacts and chain.name in contacts:
            contacts_now.update(contacts[chain.name])

    if not contacts_now:
        warn('{}: no contacts with chain {} observed, no output'.format(filename, args.S1_chain))
        continue

    S1_domain_cuts_now = S1_domain_cuts
    if max(contacts_now) >= S1_domain_cuts[-1]:
        S1_domain_cuts_now.append(max(contacts_now)+1)
    counts, _ = histogram(list(contacts_now), S1_domain_cuts_now)
    domains_needed = list(filter(lambda i: counts[i] > 0, range(len(counts))))

    cut_range = [S1_domain_cuts_now[min(domains_needed)], S1_domain_cuts_now[max(domains_needed)+1]]

    if cut_range[1] - cut_range[0] > args.max_length:
        warn('{}: cannot cut S1 chain to the required limits without losing contacts'.format(filename))

    for residue in pdb.chain(args.S1_chain):
        if residue.number() < cut_range[0] or residue.number() > cut_range[1]:
            residue.delete()

    print(pdb, end='')
