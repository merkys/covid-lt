#!/usr/bin/env python3

import argparse, sys, warnings

parser = argparse.ArgumentParser()
parser.add_argument('files', nargs='*')
parser.add_argument('--cluster-file', help='A file to extract clustering infomation from')
parser.add_argument('--cluster-id', help='Select a particular cluster')
parser.add_argument('--disjoint-clusters', action='store_true', help='Produce disjoint clusters')
parser.add_argument('--collate', choices=['most-contacts', 'average', 'most-residues'], default='most-contacts', help='Collation method for a cluster')
parser.add_argument('--quality-map', help='File containing quality map')
parser.add_argument('--remove-nonmodelled', action='store_true', help='Remove contacts involving nonmodelled residues')
parser.add_argument('--no-sort', action='store_true', help='Sort entry IDs')
parser.add_argument('--output-graph', help='Output the disjoint cluster graph to a file (needs --disjoint-clusters)')
args = parser.parse_args()

# Process the cluster file
clusters = None
if args.cluster_file:
    file = open(args.cluster_file, 'r')
    clusters = {}
    for line in file:
        pdb_id, chain, cluster = line.rstrip().split('\t')
        if cluster not in clusters:
            clusters[cluster] = set()
        clusters[cluster].add(pdb_id + '_' + chain)

    if args.disjoint_clusters:
        from networkx import Graph, connected_components
        graph = Graph()
        for cluster in clusters:
            for member in clusters[cluster]:
                graph.add_edge(int(cluster), member)
        clusters = {}
        for c in connected_components(graph):
            clusters[len(clusters)] = [x for x in c if type(x) == str]
        if args.output_graph:
            from networkx import draw, nx_agraph
            from networkx.drawing.nx_pydot import write_dot
            draw(graph, pos=nx_agraph.graphviz_layout(graph))
            write_dot(graph, args.output_graph)

# Check for the presence of the contact map
if args.remove_nonmodelled and not args.quality_map:
    raise Exception('Removal of nonmodelled residues requires a quality map')

# Process the quality map, if given
quality = None
if args.collate == 'most-residues':
    if not args.quality_map:
        raise Exception('Collation \'most-residues\' requires a quality map')
    file = open(args.quality_map, 'r')
    quality = {}
    pdb_ids = None
    for line in file:
        if pdb_ids is None:
            pdb_ids = line.rstrip().split('\t')
        else:
            for i, is_modelled in enumerate(line.rstrip().split('\t')):
                if pdb_ids[i] not in quality:
                    quality[pdb_ids[i]] = []
                quality[pdb_ids[i]].append(is_modelled)

files = args.files
if len(files) == 0:
    files = [sys.stdin]

# Process the contact maps
for file in files:
    if isinstance(file, str):
        file = open(file, 'r')
    complex_ids = None
    contacts = None
    for line in file:
        if complex_ids is None:
            complex_ids = line.rstrip().split('\t')
            contacts = {complex_id: [] for complex_id in complex_ids}
            continue
        for i, contact in enumerate(line.rstrip().split('\t')):
            contacts[complex_ids[i]].append(contact)

    # Remove nonmodelled, if requested
    if args.remove_nonmodelled:
        for pdb_id in complex_ids:
            if pdb_id not in quality:
                warnings.warn(pdb_id + ' not in quality map')
                continue
            contacts[pdb_id] = [contacts[pdb_id][i] if quality[pdb_id][i] == 'Y' else '?' for i in range(len(contacts[pdb_id]))]

    # Attempt joining clusters
    if clusters:
        if args.cluster_id is not None:
            for complex_id in complex_ids:
                chain_name = complex_id[0:5] + complex_id[6]
                if not args.cluster_id in clusters or not chain_name in clusters[args.cluster_id]:
                    contacts.pop(complex_id)
        else:
            for cluster in clusters:
                representative = None
                cluster_ids = []
                for member in clusters[cluster]:
                    pdb_id = member[0:4]
                    chain_id = member[5]
                    complexes = [c for c in contacts if c.startswith(pdb_id) and c.endswith(chain_id)]
                    for complex_id in complexes:
                        cluster_ids.append(complex_id)
                        if representative:
                            if args.collate == 'most-contacts':
                                if contacts[representative].count('?') > contacts[complex_id].count('?'):
                                    representative = complex_id
                            elif args.collate == 'most-residues':
                                if representative not in quality or complex_id not in quality:
                                    if representative not in quality:
                                        warnings.warn(representative + ' not in quality map')
                                    if complex_id not in quality:
                                        warnings.warn(complex_id + ' not in quality map')
                                    continue
                                if quality[representative].count('Y') > quality[complex_id].count('Y'):
                                    representative = complex_id
                        else:
                            representative = complex_id
                if args.collate in ['most-contacts', 'most-residues']:
                    if not representative:
                        continue
                    for complex_id in cluster_ids:
                        if complex_id != representative:
                            contacts.pop(complex_id)
                elif cluster_ids: # 'average'
                    averaged = []
                    for i in range(len(contacts[cluster_ids[0]])):
                        cluster_contacts = []
                        for complex_id in cluster_ids:
                            if contacts[complex_id][i] != '?':
                                cluster_contacts.append(float(contacts[complex_id][i]))
                        if cluster_contacts:
                            averaged.append(sum(cluster_contacts)/len(cluster_contacts))
                        else:
                            averaged.append('?')
                    for complex_id in cluster_ids:
                        contacts.pop(complex_id)
                    if not args.no_sort:
                        cluster_ids = list(sorted(cluster_ids))
                    contacts[','.join(cluster_ids)] = averaged

    # Print the filtered contacts
    complex_ids = [complex_id for complex_id in contacts]
    if not args.no_sort:
        complex_ids = list(sorted(complex_ids))
    print(*complex_ids, sep='\t')
    if complex_ids:
        for i in range(len(contacts[complex_ids[0]])):
            print(*[contacts[complex_id][i] for complex_id in complex_ids], sep='\t')
